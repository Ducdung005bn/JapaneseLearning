<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kanji Recognizer (Canvas + Douglas–Peucker)</title>
  <style>
    :root{
      --bg:#0b0d10; --panel:#141820; --ink:#e5e7eb; --accent:#60a5fa; --accent2:#f97316;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Helvetica,Arial;}
    .wrap{max-width:1080px;margin:24px auto;padding:0 16px;}
    h1{font-size:20px;margin:0 0 12px 0;}
    .grid{display:grid;grid-template-columns:420px 1fr;gap:16px;align-items:start}
    .card{background:var(--panel);border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.25);}
    .pad{padding:12px 12px 14px}
    canvas{background:#fff;border-radius:12px;display:block;width:100%;height:auto;box-shadow:inset 0 0 0 1px rgba(0,0,0,.08)}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    button,.file{appearance:none;background:#1f2937;border:1px solid #374151;color:#e5e7eb;border-radius:10px;padding:8px 12px;font-weight:600;cursor:pointer}
    button:hover{border-color:#4b5563;background:#111827}
    .danger{background:#7f1d1d;border-color:#991b1b}
    .danger:hover{background:#450a0a}
    .accent{background:#1e3a8a;border-color:#1d4ed8}
    .accent:hover{background:#0b3868}
    .row{display:flex;align-items:center;gap:10px;margin-top:10px;flex-wrap:wrap}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .list{max-height:380px;overflow:auto}
    .item{padding:10px 12px;border-bottom:1px solid #222937;display:flex;justify-content:space-between;gap:10px}
    .score{color:#9ca3af}
    .hint{color:#9ca3af;font-size:12px;margin-top:6px}
    .badge{display:inline-block;border:1px solid #374151;padding:2px 8px;border-radius:999px;color:#cbd5e1}
    .sep{height:1px;background:#222937;margin:10px 0}
    .small{font-size:12px;color:#94a3b8}
    .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    label{color:#cbd5e1}
    input[type="range"]{width:160px}
    .legend{display:flex;align-items:center;gap:10px}
    .dot{width:10px;height:10px;border-radius:2px;display:inline-block}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Kanji Recognizer – Canvas + Douglas–Peucker</h1>
  <div class="grid">
    <div class="card pad">
      <canvas id="board" width="400" height="400"></canvas>
      <div class="row legend">
        <span class="dot" style="background:#111"></span><span class="small">Raw strokes</span>
        <span class="dot" style="background:#ef4444"></span><span class="small">Simplified (Douglas–Peucker)</span>
      </div>
      <div class="toolbar">
        <button id="undo">Undo</button>
        <button id="clear" class="danger">Clear</button>
        <button id="recognize" class="accent">Recognize</button>
        <label class="badge">Epsilon <input id="eps" type="range" min="0" max="20" step="1" value="3"> <span id="epsv" class="mono">3.0</span></label>
      </div>
      <div class="row">
        <input id="file" class="file" type="file" accept="application/json" />
        <span class="small">Load Kanji DB (optional). Format: {"字": [[[x,y],...], ...], ...}</span>
      </div>
      <div class="hint">Tip: draw with mouse (desktop) or finger (mobile). Use Undo to remove last stroke.
      </div>
    </div>

    <div class="card pad">
      <div class="row" style="justify-content:space-between">
        <div><b>Top matches</b></div>
        <div class="small" id="dbinfo"></div>
      </div>
      <div class="sep"></div>
      <div id="results" class="list"></div>
      <div class="sep"></div>
      <div class="small">This is a demo. If you don't load a DB, it uses a tiny built‑in sample (一, 十, 人, 大). Matching is order‑invariant, based on normalized average nearest‑neighbor distance between point clouds.</div>
    </div>
  </div>
</div>

<script>
// ============= Utility Math ==================
function dist(a,b){const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy)}
function bbox(points){
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(const p of points){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; }
  return {minX,minY,maxX,maxY,w:Math.max(1,maxX-minX),h:Math.max(1,maxY-minY)}
}
function normalizeStrokes(strokes){
  // Flatten then normalize to unit square while preserving aspect ratio and centering
  const all = strokes.flat();
  if(all.length===0) return strokes;
  const bb=bbox(all);
  const scale=1/Math.max(bb.w,bb.h);
  const cx = (bb.minX+bb.maxX)/2, cy=(bb.minY+bb.maxY)/2;
  return strokes.map(st=>st.map(p=>({x:(p.x-cx)*scale, y:(p.y-cy)*scale})));
}
function resamplePolyline(pts, n){
  if(!pts || pts.length===0) return [];
  if(pts.length===1) return Array.from({length:n},()=>({x:pts[0].x, y:pts[0].y}));

  const L=[0];
  for(let i=1;i<pts.length;i++) L[i]=L[i-1]+dist(pts[i-1],pts[i]);
  const total=L[L.length-1];
  if(total===0) return Array.from({length:n},()=>({x:pts[0].x,y:pts[0].y}));

  const out=[];
  for(let i=0;i<n;i++){
    const t = (i*(total/(n-1)));
    let j=1; while(j<L.length && L[j]<t) j++;
    if(j>=pts.length) j=pts.length-1;
    // Clamp j-1 to valid range
    let j0 = Math.max(0, j-1), j1 = j;
    // Clamp t0/t1 to valid range
    const t0 = L[j0], t1 = L[j1];
    const p0 = pts[j0], p1 = pts[j1];
    // If t1 == t0, avoid division by zero
    const denom = Math.max(1e-9, t1 - t0);
    const u = denom === 0 ? 0 : (t - t0) / denom;
    out.push({x:p0.x + (p1.x-p0.x)*u, y:p0.y + (p1.y-p0.y)*u});
  }
  return out;
}

function resampleStrokes(strokes, perStroke=16, maxStrokes=8){
  // Limit number of strokes by merging extras
  const s = strokes.slice(0, maxStrokes);
  return s
    .filter(st => st && st.length>0)  // ← bỏ stroke rỗng
    .map(st => resamplePolyline(st, perStroke));

}
function averageNNDistance(A,B){
  if(A.length===0||B.length===0) return 1e9;
  let sum=0;
  for(const a of A){ let m=Infinity; for(const b of B){ const d=dist(a,b); if(d<m) m=d; } sum+=m; }
  return sum/A.length;
}
function setToPoints(strokes){ return strokes.flat(); }

// ============= Douglas–Peucker ==================
function perpDistance(pt, a, b){
  const dx=b.x-a.x, dy=b.y-a.y;
  if(dx===0&&dy===0) return Math.hypot(pt.x-a.x, pt.y-a.y);
  const t=((pt.x-a.x)*dx+(pt.y-a.y)*dy)/(dx*dx+dy*dy);
  const proj={x:a.x+t*dx, y:a.y+t*dy};
  return Math.hypot(pt.x-proj.x, pt.y-proj.y);
}
function douglasPeucker(pts, eps){
  if(pts.length<3) return pts.slice();
  let dmax=0, idx=0; const start=pts[0], end=pts[pts.length-1];
  for(let i=1;i<pts.length-1;i++){ const d=perpDistance(pts[i], start, end); if(d>dmax){dmax=d; idx=i;} }
  if(dmax>eps){
    const left=douglasPeucker(pts.slice(0,idx+1), eps);
    const right=douglasPeucker(pts.slice(idx), eps);
    return left.slice(0,-1).concat(right);
  } else {
    return [start, end];
  }
}

// ============= Canvas Drawing ==================
const cvs=document.getElementById('board');
const ctx=cvs.getContext('2d');
let drawing=false; let current=[]; let strokes=[]; let simplified=[];
const EPS = document.getElementById('eps');
const EPSV= document.getElementById('epsv'); EPS.addEventListener('input',()=>{EPSV.textContent=Number(EPS.value).toFixed(1); redraw();});

function getPos(e){
  if(e.touches&&e.touches[0]){
    const r=cvs.getBoundingClientRect();
    return {x:e.touches[0].clientX-r.left, y:e.touches[0].clientY-r.top};
  }
  return {x:e.offsetX, y:e.offsetY};
}
function begin(e){ drawing=true; current=[getPos(e)]; e.preventDefault(); }
function move(e){ if(!drawing) return; const p=getPos(e); const last=current[current.length-1]; current.push(p); ctx.strokeStyle="#111"; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(last.x,last.y); ctx.lineTo(p.x,p.y); ctx.stroke(); e.preventDefault(); }
function end(e){ if(!drawing) return; drawing=false; if(current.length>0){ strokes.push(current); current=[]; recomputeSimplified(); redraw(); } }

cvs.addEventListener('mousedown',begin); cvs.addEventListener('mousemove',move); cvs.addEventListener('mouseup',end); cvs.addEventListener('mouseleave',end);
// touch
cvs.addEventListener('touchstart',begin,{passive:false}); cvs.addEventListener('touchmove',move,{passive:false}); cvs.addEventListener('touchend',end);

function recomputeSimplified(){
  const eps=Number(EPS.value);
  simplified = strokes.map(st=>douglasPeucker(st, eps));
}
function redraw(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  // draw raw strokes (black)
  for(const st of strokes){ for(let i=1;i<st.length;i++){ const a=st[i-1], b=st[i]; ctx.strokeStyle="#111"; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); } }
  // draw simplified (red dashed)
  const eps=Number(EPS.value);
  for(const st of strokes){ const simp=douglasPeucker(st, eps); for(let i=1;i<simp.length;i++){ const a=simp[i-1], b=simp[i]; ctx.strokeStyle="#ef4444"; ctx.setLineDash([6,4]); ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); ctx.setLineDash([]); } }
}

// Buttons
 document.getElementById('undo').onclick=()=>{ if(strokes.length){strokes.pop(); recomputeSimplified(); redraw();} };
 document.getElementById('clear').onclick=()=>{ strokes=[]; simplified=[]; redraw(); };
 document.getElementById('recognize').onclick=()=> recognize();

fetch("simplified_kanjivg.json")
  .then(r => r.json())
  .then(json => {
    db = json;
    updateDBInfo();
  });

function updateDBInfo(){
  const dbinfo=document.getElementById('dbinfo');
  const n=Object.keys(db).length; 
  dbinfo.textContent=n+" kanji in DB";
}

// Load external DB JSON (optional)
// Expected format: {"字": [[[x,y],...], ...], ...} (coordinates arbitrary scale)
const fileInput=document.getElementById('file');
fileInput.onchange=async (e)=>{
  const f=e.target.files[0]; if(!f) return; const text=await f.text();
  try{
    const raw=JSON.parse(text);
    // normalize arrays -> objects {x,y} and center-scale to unit
    const out={};
    for(const [ch, strokesArr] of Object.entries(raw)){
      // convert to {x,y}
      const st = strokesArr.map(poly=> poly.map(([x,y])=>({x,y})) );
      const norm = normalizeStrokes(st);
      out[ch]=norm;
    }
    db = out; updateDBInfo(); alert('Loaded '+Object.keys(db).length+' kanji from file.');
  }catch(err){ alert('Invalid JSON: '+err.message); }
};

function recognize(){
  if(strokes.length===0){
    console.log("No strokes drawn yet.");
    document.getElementById('results').innerHTML='<div class="item">Draw something first.</div>';
    return;
  }

  // Use simplified strokes
  recomputeSimplified();
  console.log("Simplified strokes:", simplified);

  // normalize to unit square
  const norm = normalizeStrokes(simplified);
  console.log("Normalized strokes:", norm);

  // resample each stroke to fixed points
  const RES_PER_STROKE=16, MAX_STROKES=8;
  const sampled = resampleStrokes(norm, RES_PER_STROKE, MAX_STROKES);
  console.log("Sampled strokes:", sampled);

  const A = setToPoints(sampled);
  console.log("Flattened points A:", A);

  const results=[];
  for(const [ch, model] of Object.entries(db)){
    const mNorm = normalizeStrokes(model);
    const mSampled = resampleStrokes(mNorm, RES_PER_STROKE, MAX_STROKES);
    const B = setToPoints(mSampled);

    const d1 = averageNNDistance(A,B);
    const d2 = averageNNDistance(B,A);
    const d = (d1+d2)/2;
    const score = Math.max(0, 1 - d*1.8);

    results.push({ch, score, d});
  }

  results.sort((a,b)=> b.score - a.score);
  console.log("Top 10 results:", results.slice(0,10));
  renderResults(results.slice(0, 10));
}


function renderResults(items){
  const el=document.getElementById('results');
  if(items.length===0){ el.innerHTML='<div class="item">No results.</div>'; return; }
  el.innerHTML = items.map(it=>
    `<div class="item"><div style="font-size:24px">${escapeHtml(it.ch)}</div><div class="score">score ${(it.score).toFixed(3)}</div></div>`
  ).join('');
}
function escapeHtml(s){return s.replace(/[&<>]/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c]))}
</script>
</body>
</html>