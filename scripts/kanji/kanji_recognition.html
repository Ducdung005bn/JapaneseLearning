<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Kanji Preprocess — DP + Resample with Peak Insertion</title>
<style>
  :root{--bg:#0b0d10;--panel:#141820;--ink:#e5e7eb}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Roboto,Arial}
  .wrap{max-width:1100px;margin:18px auto;padding:12px}
  .card{background:var(--panel);border-radius:12px;padding:12px;box-shadow:0 8px 20px rgba(0,0,0,.4)}
  canvas{background:#fff;border-radius:8px;display:block;width:420px;height:420px;touch-action:none}
  .toolbar{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap;align-items:center}
  button,input,textarea,select{font:14px}
  button{background:#1f2937;color:var(--ink);border-radius:8px;padding:8px 12px;border:1px solid #374151;cursor:pointer}
  .danger{background:#7f1d1d}
  label{font-size:13px;color:#cbd5e1;display:flex;align-items:center;gap:8px}
  .col{display:flex;flex-direction:column;gap:8px}
  .row{display:flex;gap:12px;align-items:center;margin-top:10px}
  .small{font-size:13px;color:#94a3b8}
  textarea{width:380px;height:96px;background:#071018;color:#dbeafe;border-radius:6px;padding:8px;border:1px solid #0f172a}
  #output{margin-top:10px;white-space:pre-wrap;font-family:monospace;background:#071018;padding:8px;border-radius:6px;max-height:320px;overflow:auto}
</style>
</head>
<body>
<div class="wrap">
  <h2>Kanji Preprocess — DP + Resample with Peak Insertion</h2>
  <div class="card" style="display:flex;gap:16px">
    <div>
      <canvas id="canvas" width="840" height="840" aria-label="drawing canvas"></canvas>

      <div class="toolbar">
        <button id="undo">Undo</button>
        <button id="clear" class="danger">Clear</button>
        <button id="recognize">Recognize & Export</button>

        <label class="small">ε (DP)
          <input id="eps" type="range" min="0" max="0.1" step="0.01" value="0.05" style="width:140px">
          <span id="epsVal">0.003</span>
        </label>

        <label class="small">N_base
          <input id="Nbase" type="range" min="8" max="128" step="1" value="48" style="width:100px">
          <span id="NVal">48</span>
        </label>

        <label class="small">N_min
          <input id="Nmin" type="number" min="1" max="64" value="8" style="width:64px">
        </label>

        <label class="small">N_max
          <input id="Nmax" type="number" min="8" max="512" value="256" style="width:72px">
        </label>

        <label class="small">peakMult (threshold)
          <input id="peakMult" type="range" min="0" max="3" step="0.1" value="1.0" style="width:100px">
          <span id="peakVal">1.0</span>
        </label>
      </div>

      <div style="margin-top:8px" class="small">Draw strokes (mouse/touch) or paste a KanjiVG path `d="..."` and press Import.</div>

      <div style="display:flex;gap:8px;margin-top:8px">
        <textarea id="svgpath" placeholder='Paste path d attribute here (e.g. M32.68,11.13c0.72...)'></textarea>
        <div class="col" style="min-width:260px">
          <label class="small">viewBox size (KanjiVG): <input id="vb" value="109" style="width:72px"></label>
          <button id="importPath">Import Path</button>
          <div class="small" id="stats">Strokes: 0 | Raw pts: 0 | Simplified pts: 0</div>
        </div>
      </div>
    </div>

    <div style="flex:1;min-width:300px">
      <div class="small">Output (normalized resampled strokes)</div>
      <div id="output">Press Recognize to normalize & export JSON of resampled strokes (coords in [0,1]).</div>
      <div style="height:12px"></div>
      <div class="small">Notes:
        <ul>
          <li>Pipeline: flatten → normalize all → DP → detect peaks → compute N per stroke by length → resample evenly → insert peaks & resort.</li>
          <li>Peaks are <b>forcibly inserted</b> into resampled points so they won't be lost.</li>
        </ul>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const CSS_SIZE = 420;
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const DPR = window.devicePixelRatio || 1;
  canvas.style.width = CSS_SIZE + 'px';
  canvas.style.height = CSS_SIZE + 'px';
  canvas.width = CSS_SIZE * DPR;
  canvas.height = CSS_SIZE * DPR;
  ctx.scale(DPR, DPR);

  // State (raw in pixel coords)
  let raw = []; // strokes: array of [{x,y},...]
  let simplified = []; // normalized dp strokes [0..1]
  let resampled = [];  // normalized resampled (with peaks)
  let curStroke = null, drawing = false;

  // UI
  const epsEl = document.getElementById('eps'), epsVal = document.getElementById('epsVal');
  const NbaseEl = document.getElementById('Nbase'), NVal = document.getElementById('NVal');
  const NminEl = document.getElementById('Nmin'), NmaxEl = document.getElementById('Nmax');
  const peakMultEl = document.getElementById('peakMult'), peakVal = document.getElementById('peakVal');
  const statsEl = document.getElementById('stats'), outputEl = document.getElementById('output');

  epsVal.textContent = epsEl.value;
  NVal.textContent = NbaseEl.value;
  peakVal.textContent = peakMultEl.value;

  // Helpers
  const copyP = p => ({x: p.x, y: p.y});
  const dist = (a,b) => Math.hypot(a.x-b.x, a.y-b.y);
  function normToCanvas(p){ return { x: p.x * CSS_SIZE, y: p.y * CSS_SIZE }; }

  // SVG sampling
  function sampleSvgPath(dStr, samples = 256, viewBoxSize = 109){
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute('viewBox', `0 0 ${viewBoxSize} ${viewBoxSize}`);
    const path = document.createElementNS(svgNS, "path");
    path.setAttribute('d', dStr);
    path.setAttribute('stroke','none');
    svg.appendChild(path);
    path.style.visibility = 'hidden';
    document.body.appendChild(svg);
    const L = path.getTotalLength();
    const pts = [];
    for(let i=0;i<samples;i++){
      const t = i/(samples-1);
      const p = path.getPointAtLength(t*L);
      pts.push({ x: p.x * (CSS_SIZE / viewBoxSize), y: p.y * (CSS_SIZE / viewBoxSize) });
    }
    document.body.removeChild(svg);
    return pts;
  }

  // Normalize all strokes (pixel -> normalized [0,1] centered at 0.5)
  function normalizeAll(strokes){
    const pts = [];
    for(const s of strokes) for(const p of s) pts.push(p);
    if(pts.length === 0) return strokes.map(s => s.map(()=>({x:0.5,y:0.5})));
    const xs = pts.map(p=>p.x), ys = pts.map(p=>p.y);
    const minX = Math.min(...xs), maxX = Math.max(...xs), minY = Math.min(...ys), maxY = Math.max(...ys);
    let W = maxX - minX, H = maxY - minY; if(W===0 && H===0){ W = H = 1; }
    const scale = 1 / Math.max(W, H);
    const cx = (minX + maxX)/2, cy = (minY + maxY)/2;
    const tx = 0.5 - ((cx - minX) * scale);
    const ty = 0.5 - ((cy - minY) * scale);
    return strokes.map(st => st.map(p => ({ x: (p.x - minX) * scale + tx, y: (p.y - minY) * scale + ty })));
  }

  // Douglas-Peucker (normalized coords)
  function perpDist(pt,a,b){
    const vx = b.x - a.x, vy = b.y - a.y;
    const wx = pt.x - a.x, wy = pt.y - a.y;
    const denom = vx*vx + vy*vy;
    let t = denom === 0 ? 0 : (vx*wx + vy*wy) / denom;
    t = Math.max(0, Math.min(1, t));
    const px = a.x + t*vx, py = a.y + t*vy;
    return Math.hypot(pt.x-px, pt.y-py);
  }
  function douglasPeucker(points, eps){
    if(!points || points.length < 3) return points ? points.slice() : [];
    let maxd = 0, idx = 0;
    const a = points[0], b = points[points.length-1];
    for(let i=1;i<points.length-1;i++){
      const d = perpDist(points[i], a, b);
      if(d > maxd){ maxd = d; idx = i; }
    }
    if(maxd > eps){
      const left = douglasPeucker(points.slice(0, idx+1), eps);
      const right = douglasPeucker(points.slice(idx), eps);
      return left.slice(0,-1).concat(right);
    } else {
      return [a, b];
    }
  }

  // length & curvature (normalized)
  function strokeLength(points){
    let L = 0; for(let i=1;i<points.length;i++) L += dist(points[i], points[i-1]);
    return L;
  }
  function computeCurvature(points){
    const n = points.length;
    if(n < 3) return Array(n).fill(0);
    const curv = Array(n).fill(0);
    for(let i=1;i<n-1;i++){
      const p0 = points[i-1], p1 = points[i], p2 = points[i+1];
      const v1x = p1.x - p0.x, v1y = p1.y - p0.y;
      const v2x = p2.x - p1.x, v2y = p2.y - p1.y;
      const a = Math.hypot(v1x,v1y), b = Math.hypot(v2x,v2y);
      if(a===0||b===0){ curv[i]=0; continue; }
      let dot = (v1x*v2x + v1y*v2y) / (a*b); dot = Math.max(-1, Math.min(1, dot));
      const angle = Math.acos(dot);
      const denom = (a + b)/2;
      curv[i] = denom>0 ? angle/denom : angle;
    }
    curv[0] = curv[1] || 0; curv[n-1] = curv[n-2] || 0;
    return curv;
  }
  function meanStd(arr){
    if(arr.length===0) return {mean:0,std:0};
    const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
    const varr = arr.reduce((s,v)=> s + (v-mean)*(v-mean), 0)/arr.length;
    return {mean, std: Math.sqrt(varr)};
  }

  // compute N per stroke by length (by_mean)
  function computeNsByLength(lengths, opts){
    const N_base = opts.N_base || 48, N_min = opts.N_min || 8, N_max = opts.N_max || 256;
    const mean = lengths.reduce((a,b)=>a+b,0) / Math.max(1, lengths.length);
    return lengths.map(L => {
      let n = Math.round(N_base * (L / Math.max(1e-9, mean)));
      n = Math.max(N_min, Math.min(N_max, n));
      return n;
    });
  }

  // resample uniformly by arc-length to exactly N points
  function resamplePolyline(points, N){
    if(!points || points.length === 0) return Array.from({length:N}, ()=>({x:0.5,y:0.5}));
    const seg = [];
    for(let i=1;i<points.length;i++) seg.push(dist(points[i], points[i-1]));
    const total = seg.reduce((a,b)=>a+b,0);
    if(total === 0) return Array.from({length:N}, ()=> ({x:points[0].x, y:points[0].y}));
    const step = total / (N-1);
    const res = [];
    let curSeg = 0, acc = 0;
    for(let k=0;k<N;k++){
      const target = k * step;
      while(curSeg < seg.length && acc + seg[curSeg] < target){ acc += seg[curSeg]; curSeg++; }
      if(curSeg >= seg.length){ res.push({x: points[points.length-1].x, y: points[points.length-1].y}); continue; }
      const p0 = points[curSeg], p1 = points[curSeg+1];
      const remain = target - acc;
      const u = (seg[curSeg] === 0) ? 0 : (remain / seg[curSeg]);
      res.push({ x: p0.x + (p1.x - p0.x) * u, y: p0.y + (p1.y - p0.y) * u });
    }
    return res;
  }

  // project point onto polyline -> returns distance along polyline (0..totalLen)
  function projectPointToPolyline(point, poly){
    let best = {d: Infinity, segIdx: 0, t: 0, distOnPath: 0};
    let accLen = 0;
    for(let i=0;i<poly.length-1;i++){
      const a = poly[i], b = poly[i+1];
      const vx = b.x - a.x, vy = b.y - a.y;
      const wx = point.x - a.x, wy = point.y - a.y;
      const denom = vx*vx + vy*vy;
      let t = denom === 0 ? 0 : (vx*wx + vy*wy)/denom;
      t = Math.max(0, Math.min(1, t));
      const px = a.x + t*vx, py = a.y + t*vy;
      const d = Math.hypot(point.x - px, point.y - py);
      // compute distance along path to this projection
      // need seg length
      let segLen = Math.hypot(vx, vy);
      const distOnPath = accLen + t * segLen;
      if(d < best.d){ best = {d, segIdx:i, t, distOnPath}; }
      accLen += segLen;
    }
    return best; // distOnPath is key
  }

  // detect curvature peaks indices (normalized coords)
  function detectPeaks(points, mult = 1.0){
    const curv = computeCurvature(points);
    const {mean, std} = meanStd(curv);
    const peaks = [];
    for(let i=1;i<curv.length-1;i++){
      if(curv[i] > mult * std) peaks.push(i);
    }
    return peaks;
  }

  // Insert peaks into resampled list forcibly: convert peak indices to coordinates,
  // add them to resampled points, then sort all points along DP stroke's arc-length.
  function insertPeaksIntoResampled(dpStroke, resampledPts, peakIndices){
    if(!peakIndices || peakIndices.length === 0) return resampledPts;
    // convert peak indices to coordinates on dpStroke
    const peaks = peakIndices.map(idx => dpStroke[idx]);
    // for each point (resampled + peaks) compute its path distance along dpStroke
    const all = resampledPts.concat(peaks);
    // compute cumulative lengths of dpStroke for projection
    // project each point to dpStroke to get distOnPath
    const projected = all.map(p => {
      const pr = projectPointToPolyline(p, dpStroke);
      return {p, dist: pr.distOnPath};
    });
    // sort by dist
    projected.sort((a,b) => a.dist - b.dist);
    // deduplicate very-close points (epsilon)
    const eps = 1e-4;
    const unique = [];
    for(const item of projected){
      const last = unique[unique.length-1];
      if(!last || Math.hypot(last.x - item.p.x, last.y - item.p.y) > eps){
        unique.push({x: item.p.x, y: item.p.y});
      }
    }
    return unique;
  }

  // Master pipeline: normalize -> DP -> compute Ns -> detect peaks -> resample -> insert peaks
  function processPipeline(){
    // 1. normalize raw
    const norm = normalizeAll(raw);
    // 2. dp
    const eps = parseFloat(epsEl.value);
    const dpStrokes = norm.map(st => douglasPeucker(st, eps));
    // 3. lengths
    const lengths = dpStrokes.map(st => strokeLength(st));
    const N_base = parseInt(NbaseEl.value,10);
    const N_min = Math.max(1, parseInt(NminEl.value,10));
    const N_max = Math.max(N_min, parseInt(NmaxEl.value,10));
    let Ns = computeNsByLength(lengths, {N_base, N_min, N_max});
    // 4. detect peaks and force include
    const peakMult = parseFloat(peakMultEl.value);
    const peaksByStroke = dpStrokes.map(st => detectPeaks(st, peakMult));
    // add peaks count to Ns to ensure we have enough points
    for(let i=0;i<Ns.length;i++){ Ns[i] = Math.max(Ns[i], Ns[i] + (peaksByStroke[i]||[]).length); }
    // 5. resample and insert peaks
    const res = [];
    for(let i=0;i<dpStrokes.length;i++){
      const dp = dpStrokes[i];
      const Ni = Ns[i];
      const baseRes = resamplePolyline(dp, Ni);
      const withPeaks = insertPeaksIntoResampled(dp, baseRes, peaksByStroke[i]);
      // ensure we still have at least Ni points (if peaks dedup caused fewer, resample to Ni first then insert)
      let final;
      if(withPeaks.length >= Ni) final = withPeaks;
      else {
        // resample to Ni and then forcibly add peaks and resort
        const more = resamplePolyline(dp, Ni);
        final = insertPeaksIntoResampled(dp, more, peaksByStroke[i]);
      }
      res.push(final);
    }

    simplified = dpStrokes;
    resampled = res;
    drawAll();
    const rawPts = raw.reduce((a,b)=>a+b.length,0);
    const simpPts = simplified.reduce((a,b)=>a+b.length,0);
    statsEl.textContent = `Strokes: ${raw.length} | Raw pts: ${rawPts} | Simplified pts: ${simpPts}`;
  }

  // draw: raw strokes (pixel), simplified+resampled (normalized -> map to canvas)
  function drawAll(){
    ctx.clearRect(0,0,CSS_SIZE,CSS_SIZE);
    // raw strokes
    ctx.lineWidth = 4; ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.strokeStyle = 'rgba(0,0,0,0.18)';
    for(const st of raw){
      if(!st || st.length<2) continue;
      ctx.beginPath(); ctx.moveTo(st[0].x, st[0].y);
      for(let i=1;i<st.length;i++) ctx.lineTo(st[i].x, st[i].y);
      ctx.stroke();
    }
    // simplified (dashed red) from normalized
    if(simplified && simplified.length){
      ctx.setLineDash([6,6]); ctx.lineWidth = 2; ctx.strokeStyle = '#ef4444';
      for(const st of simplified){
        if(!st || st.length<2) continue;
        ctx.beginPath(); const p0 = normToCanvas(st[0]); ctx.moveTo(p0.x, p0.y);
        for(let i=1;i<st.length;i++){ const p = normToCanvas(st[i]); ctx.lineTo(p.x, p.y); }
        ctx.stroke();
      }
      ctx.setLineDash([]);
    }
    // resampled (blue) and peaks (yellow outline)
    if(resampled && resampled.length){
      ctx.fillStyle = '#1e40af';
      for(const set of resampled){
        if(!set) continue;
        for(const p of set){
          const q = normToCanvas(p);
          ctx.beginPath(); ctx.arc(q.x,q.y,4,0,Math.PI*2); ctx.fill();
        }
      }
      // peaks: compute from simplified and draw outline
      ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 2;
      for(const st of simplified){
        const pk = detectPeaks(st, parseFloat(peakMultEl.value));
        for(const idx of pk){
          const q = normToCanvas(st[idx]);
          ctx.beginPath(); ctx.arc(q.x,q.y,6,0,Math.PI*2); ctx.stroke();
        }
      }
    }
    // current stroke live (pixel)
    if(curStroke && curStroke.length){
      ctx.lineWidth = 4; ctx.strokeStyle = '#111';
      ctx.beginPath(); ctx.moveTo(curStroke[0].x, curStroke[0].y);
      for(let i=1;i<curStroke.length;i++) ctx.lineTo(curStroke[i].x, curStroke[i].y);
      ctx.stroke();
    }
  }

  // Input handling
  function pagePt(e){ const r = canvas.getBoundingClientRect(); const p = e.touches ? e.touches[0] : e; return { x: p.clientX - r.left, y: p.clientY - r.top }; }
  canvas.addEventListener('mousedown', e => { e.preventDefault(); drawing = true; curStroke = [ pagePt(e) ]; drawAll(); });
  window.addEventListener('mousemove', e => { if(!drawing) return; const p = pagePt(e); const last = curStroke[curStroke.length-1]; if(!last || dist(last,p) > 0.5) curStroke.push(p); drawAll(); });
  window.addEventListener('mouseup', e => { if(!drawing) return; drawing=false; if(curStroke && curStroke.length>1){ raw.push(curStroke.map(copyP)); processPipeline(); } curStroke=null; drawAll(); });
  canvas.addEventListener('touchstart', e => { e.preventDefault(); drawing = true; curStroke = [ pagePt(e) ]; drawAll(); });
  canvas.addEventListener('touchmove', e => { e.preventDefault(); if(!drawing) return; const p = pagePt(e); const last = curStroke[curStroke.length-1]; if(!last || dist(last,p) > 0.5) curStroke.push(p); drawAll(); });
  canvas.addEventListener('touchend', e => { e.preventDefault(); if(!drawing) return; drawing=false; if(curStroke && curStroke.length>1){ raw.push(curStroke.map(copyP)); processPipeline(); } curStroke=null; drawAll(); });

  // import path
  document.getElementById('importPath').addEventListener('click', ()=>{
    const d = document.getElementById('svgpath').value.trim();
    if(!d){ alert('Paste path d'); return; }
    const viewBox = parseFloat(document.getElementById('vb').value) || 109;
    try{
      const pts = sampleSvgPath(d, 256, viewBox);
      raw.push(pts);
      document.getElementById('svgpath').value = '';
      processPipeline();
    }catch(err){ alert('Parse error: ' + err); }
  });

  // controls
  document.getElementById('undo').addEventListener('click', ()=>{ raw.pop(); processPipeline(); drawAll(); });
  document.getElementById('clear').addEventListener('click', ()=>{ raw.length=0; simplified.length=0; resampled.length=0; outputEl.textContent=''; statsEl.textContent='Strokes: 0 | Raw pts: 0 | Simplified pts: 0'; drawAll(); });
  epsEl.addEventListener('input', ()=>{ epsVal.textContent = epsEl.value; processPipeline(); });
  NbaseEl.addEventListener('input', ()=>{ NVal.textContent = NbaseEl.value; processPipeline(); });
  peakMultEl.addEventListener('input', ()=>{ peakVal.textContent = peakMultEl.value; processPipeline(); });
  NminEl.addEventListener('change', ()=> processPipeline());
  NmaxEl.addEventListener('change', ()=> processPipeline());

  // Recognize
  document.getElementById('recognize').addEventListener('click', ()=>{
    processPipeline();
    // resampled are normalized coords (0..1), export
    const json = resampled.map(st => st.map(p => [+p.x.toFixed(6), +p.y.toFixed(6)]));
    outputEl.textContent = JSON.stringify({N_base: parseInt(NbaseEl.value,10), N_min: parseInt(NminEl.value,10), N_max: parseInt(NmaxEl.value,10), strokes: json}, null, 2);
  });

  // initial draw
  drawAll();

})();
</script>
</body>
</html>
